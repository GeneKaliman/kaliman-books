<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Браузерный ридер — надёжная загрузка</title>
  <style>
    :root{ --bg:#0b0b0c; --fg:#e7e7ea; --muted:#9aa0a6; --accent:#8ab4f8; --bar:rgba(0,0,0,.7); --pageW: 960px; }
    *{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
    html,body{ height:100%; overflow-x:auto; touch-action: pan-x pan-y pinch-zoom; overscroll-behavior: contain; }
    body{ margin:0; background:var(--bg); color:var(--fg); font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Inter,Arial,sans-serif; }
    .topbar{ position:fixed; inset:0 0 auto 0; z-index:1000; display:flex; align-items:center; gap:10px;
      padding: env(safe-area-inset-top) 10px 10px 10px; backdrop-filter: blur(6px); background:var(--bar);
      pointer-events:auto; transform-origin:0 0; }
    .btn{ border:0; border-radius:12px; padding:8px 12px; background:rgba(255,255,255,.06); color:var(--fg); font-size:16px; cursor:pointer; }
    .btn:active{ background:rgba(255,255,255,.1); }
    .spacer{ flex:1; }
    .pages{ position:relative; width:100%; max-width:1200px; margin:0 auto; padding-top: calc(48px + env(safe-area-inset-top)); padding-bottom: 24px; }
    .page{ margin:12px 0; width:100%; } .sheet{ width: var(--pageW); margin: 0 auto; }
    .sheet canvas{ display:block; background:#fff; box-shadow: 0 6px 26px rgba(0,0,0,.36); }
    .progress{ position:fixed; left:0; right:0; bottom:0; height:3px; background:rgba(255,255,255,.08); z-index:900; transform:translateY(-3px); transform-origin:0 100%; }
    .progress > span{ display:block; height:100%; width:0; background:var(--accent); transition:width .2s; }
    #spinner{ position:fixed; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:2000; background:rgba(0,0,0,.5); color:var(--fg); font-size:16px; pointer-events:none; transition:opacity .3s; text-align:center; padding:0 12px;}
    #spinner.hidden{ opacity:0; pointer-events:none; display:none; }
    #spinner .icon{ width:48px; height:48px; border:4px solid rgba(255,255,255,.4); border-top-color:var(--accent); border-radius:50%; animation:spin 1s linear infinite; margin-bottom:12px; }
    #diag{ position:fixed; left:8px; bottom:8px; right:8px; background:#111; border:1px solid #333; color:#ddd; padding:8px 10px; font-size:12px; border-radius:8px; opacity:.9; }
    @keyframes spin{ from{ transform:rotate(0deg);} to{ transform:rotate(360deg);} }
  </style>
</head>
<body>
  <div class="topbar" id="topbar">
    <button id="menuBtn" class="btn">☰ Меню</button>
    <div class="spacer"></div>
    <button id="resetFit" class="btn" title="Сброс под текущую ориентацию">Сброс</button>
  </div>

  <div class="pages" id="pages"></div>
  <div class="progress" id="progress"><span id="progressBar"></span></div>

  <div id="spinner"><div class="icon"></div><div id="spinText">Пожалуйста, подождите…</div></div>
  <div id="diag">Диагностика: инициализация…</div>

  <script>
  // ------------------ Robust loader ------------------
  const PDF_CANDIDATES = [
    './History_Climate.pdf',
    './HistoryClimate.pdf',
    './history_climate.pdf',
    './History_Climate.PDF',
    './HistoryClimate.PDF'
  ];
  const CDNS = [
    { core:'https://unpkg.com/pdfjs-dist@4.4.168/build/pdf.min.js', worker:'https://unpkg.com/pdfjs-dist@4.4.168/build/pdf.worker.min.js' },
    { core:'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.min.js', worker:'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.worker.min.js' },
    { core:'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.4.168/build/pdf.min.js', worker:'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.4.168/build/pdf.worker.min.js' }
  ];
  const diag = (m)=>{ document.getElementById('diag').textContent = 'Диагностика: ' + m; };

  (async function boot(){
    // 1) Find a working CDN pair and set workerSrc explicitly
    let okCdn = null;
    for (const c of CDNS){
      try{
        await new Promise((res,rej)=>{ const s=document.createElement('script'); s.src=c.core; s.async=true; s.crossOrigin='anonymous'; s.onload=()=>res(); s.onerror=()=>rej(new Error('core failed')); document.head.appendChild(s); });
        if (!window.pdfjsLib) throw new Error('pdfjsLib missing after core');
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = c.worker; // explicit worker path
        // quick probe worker fetch
        await fetch(c.worker, {mode:'no-cors'}).catch(()=>{});
        okCdn = c; diag('pdf.js загружен: '+c.core); break;
      }catch(e){ diag('Не удалось загрузить pdf.js с '+c.core+' — '+e.message); }
    }
    if (!okCdn){ diag('Все CDN отклонены. Разрешите загрузку скриптов (unpkg/cdnjs/jsdelivr) или используйте локальный pdf.min.js.'); document.getElementById('spinText').textContent='pdf.js не загружен.'; return; }

    // 2) Find the PDF via GET (HEAD sometimes blocked)
    let pdfUrl = null, lastErr='';
    for (const u of PDF_CANDIDATES){
      try{
        const r = await fetch(u, {cache:'no-store'});
        if (r.ok){ pdfUrl = u; diag('PDF найден: '+u); break; }
        lastErr = 'HTTP '+r.status+' '+u;
      }catch(e){ lastErr = e.message+' '+u; }
    }
    if (!pdfUrl){ diag('PDF не найден: '+lastErr); document.getElementById('spinText').textContent='Не удалось найти PDF. Положите файл рядом с HTML и назовите '+PDF_CANDIDATES.join(', '); return; }

    // 3) Start viewer
    startViewer(pdfUrl);
  })();

  // ------------------ Viewer (fast pipeline) ------------------
  const pagesEl = document.getElementById('pages');
  const spinner = document.getElementById('spinner');
  const spinText = document.getElementById('spinText');
  const progressBar = document.getElementById('progressBar');
  const resetFitBtn = document.getElementById('resetFit');
  const topbarEl = document.getElementById('topbar');
  let pdfDoc=null,totalPages=0,baselineW=960,lastVVW=0,lastScale=1;
  let pageMetaCache={},renderTasks={},vvScale=1,pageAspect=0.707,menuVisible=true;

  function getVVWidth(){ return Math.floor((window.visualViewport && window.visualViewport.width) || document.documentElement.clientWidth); }
  function getVVHeight(){ return Math.floor((window.visualViewport && window.visualViewport.height) || window.innerHeight); }
  function effectiveDPR(){ vvScale = (window.visualViewport && window.visualViewport.scale) || 1; return (window.devicePixelRatio || 1) * (vvScale || 1); }
  function setPageWidth(w){
    baselineW = Math.round(w);
    document.documentElement.style.setProperty('--pageW', baselineW + 'px');
    document.querySelectorAll('.page .sheet canvas').forEach((cv)=>{
      const pn = parseInt(cv.id.replace('p',''),10);
      const meta = pageMetaCache[pn];
      const cssH = meta ? Math.round(baselineW * (meta.h/meta.w)) : Math.round(baselineW / (pageAspect||0.707));
      cv.style.width = baselineW + 'px';
      cv.style.height = cssH + 'px';
      cv.dataset.rendered = '0';
    });
  }
  function computeFitWidth(){
    const vw = getVVWidth(), vh = getVVHeight();
    const topH = topbarEl ? topbarEl.offsetHeight : 0, bottomMargin = 80;
    const widthPortrait = vw;
    const widthLandscape = Math.min(vw, Math.max(160, (vh - topH - bottomMargin) * (pageAspect || 0.707)));
    return Math.min(1200, Math.max(160, (vh >= vw) ? widthPortrait : widthLandscape));
  }
  function updateFixedPositions(){
    const vv = window.visualViewport; if (!vv) return;
    const x = vv.offsetLeft||0, y = vv.offsetTop||0, scale = vv.scale||1;
    topbarEl.style.transform = `translate(${x}px, ${y}px) scale(${1/scale})`;
    document.getElementById('progress').style.transform = `translate(${x}px, -3px) scale(${1/scale})`;
  }
  function rerenderVisible(){
    const pages = document.querySelectorAll('.page'); const vh = window.innerHeight;
    pages.forEach(p=>{ const r = p.getBoundingClientRect(); const near = r.top < vh*2 && r.bottom > -vh*1;
      if (near){ const n = parseInt(p.dataset.page,10); const c = p.querySelector('canvas'); c.dataset.rendered='0'; renderPage(n,c); } });
  }
  function onVVChange(){
    const vv = window.visualViewport; const nowW = vv ? vv.width : document.documentElement.clientWidth;
    const nowScale = vv ? vv.scale : 1; const widthDelta = Math.abs(nowW - lastVVW); const scaleDelta = Math.abs((nowScale||1)-(lastScale||1));
    lastVVW = nowW; lastScale = nowScale;
    if (widthDelta > 120){ setPageWidth(computeFitWidth()); rerenderVisible(); updateFixedPositions(); }
    else if (scaleDelta > 0.02){ rerenderVisible(); updateFixedPositions(); }
  }
  if (window.visualViewport){
    const schedule = (()=>{ let raf=0; return ()=>{ if (raf) return; raf=requestAnimationFrame(()=>{ raf=0; onVVChange(); }); }; })();
    window.visualViewport.addEventListener('resize', schedule);
    window.visualViewport.addEventListener('scroll', schedule);
    window.visualViewport.addEventListener('resize', updateFixedPositions);
    window.visualViewport.addEventListener('scroll', updateFixedPositions);
    updateFixedPositions();
  }else{
    window.addEventListener('resize', ()=>{ clearTimeout(window.__rt); window.__rt = setTimeout(onVVChange, 80); });
  }
  window.addEventListener('orientationchange', ()=> setTimeout(onVVChange, 220));
  resetFitBtn.addEventListener('click', ()=>{ setPageWidth(computeFitWidth()); rerenderVisible(); window.scrollTo({top:0,behavior:'smooth'}); });
  pagesEl.addEventListener('click', (e)=>{ if (topbarEl.contains(e.target)) return; const show = topbarEl.style.display !== 'flex'; topbarEl.style.display = show?'flex':'none'; document.getElementById('progress').style.display = show?'block':'none'; });

  async function startViewer(pdfUrl){
    try{
      // Try a simple GET first to surface HTTP errors in our diagnostics
      const probe = await fetch(pdfUrl, {cache:'no-store'});
      if (!probe.ok) throw new Error('HTTP '+probe.status+' для '+pdfUrl);
    }catch(e){
      document.getElementById('spinText').textContent = 'PDF доступен, но не читается: '+e.message;
      // Proceed anyway—pdf.js may still handle it if CORS is fine.
    }
    try{
      pdfDoc = await pdfjsLib.getDocument({ url: pdfUrl }).promise;
      const n = pdfDoc.numPages; const frag = document.createDocumentFragment();
      for (let i=1;i<=n;i++){ const holder=document.createElement('div'); holder.className='page'; holder.dataset.page=String(i);
        const sheet=document.createElement('div'); sheet.className='sheet'; const canvas=document.createElement('canvas'); canvas.id='p'+i;
        sheet.appendChild(canvas); holder.appendChild(sheet); frag.appendChild(holder); }
      pagesEl.appendChild(frag);
      const page1 = await ensureMeta(1); // determine precise aspect
      pageAspect = page1.w / page1.h; setPageWidth(computeFitWidth());
      observeAndRender();
      setTimeout(()=>{ if(!spinner.classList.contains('hidden')){ document.getElementById('spinText').textContent='Долго загружается…'; } }, 5000);
    }catch(err){
      document.getElementById('spinText').textContent = 'Ошибка инициализации pdf.js: '+err.message;
    }
  }
  let metaCache={};
  async function ensureMeta(i){ if (metaCache[i]) return metaCache[i]; const p = await pdfDoc.getPage(i); const vp = p.getViewport({scale:1}); return metaCache[i] = {w:vp.width,h:vp.height,page:p}; }
  let io=null;
  function observeAndRender(){
    if (io) io.disconnect();
    io = new IntersectionObserver(async (entries)=>{
      for (const e of entries){
        if (!e.isIntersecting) continue;
        const n = parseInt(e.target.dataset.page,10);
        const c = e.target.querySelector('canvas');
        if (c.dataset.rendering==='1' || c.dataset.rendered==='1') continue;
        await render(n,c);
      }
    }, {root:null, rootMargin:'1800px 0px', threshold:0.01});
    document.querySelectorAll('.page').forEach(p=> io.observe(p));
  }
  async function render(n, canvas){
    const m = await ensureMeta(n); const cssW=baselineW, cssH=Math.round(cssW*(m.h/m.w));
    const eff = (window.devicePixelRatio||1) * ((window.visualViewport && window.visualViewport.scale)||1);
    const pxW = Math.floor(cssW*eff), pxH = Math.floor(cssH*eff);
    if (canvas.width!==pxW || canvas.height!==pxH){ canvas.width=pxW; canvas.height=pxH; }
    canvas.style.width = cssW+'px'; canvas.style.height = cssH+'px';
    const ctx = canvas.getContext('2d', {alpha:false}); ctx.save(); ctx.fillStyle='#fff'; ctx.fillRect(0,0,pxW,pxH); ctx.restore();
    const vp = m.page.getViewport({ scale: cssW / m.w });
    canvas.dataset.rendering='1'; canvas.dataset.rendered='0';
    const task = m.page.render({ canvasContext: ctx, viewport: vp, transform: eff!==1 ? [eff,0,0,eff,0,0] : null });
    try{ await task.promise; canvas.dataset.rendered='1'; if (!spinner.classList.contains('hidden')) spinner.classList.add('hidden'); } finally { canvas.dataset.rendering='0'; }
    updateProgress();
  }
  function updateProgress(){ const scrollY=window.scrollY||document.documentElement.scrollTop||0;
    const full=document.documentElement.scrollHeight - window.innerHeight; const percent=full>0?Math.max(0,Math.min(100,Math.round(scrollY/full*100))):0;
    progressBar.style.width = percent + '%'; }
  window.addEventListener('scroll', updateProgress, {passive:true});
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Браузерный ридер — История климата (скролл, v9)</title>
  <style>
    :root {
      --bg: #0b0b0c;
      --pagebg: #ffffff;
      --fg: #e7e7ea;
      --muted: #9aa0a6;
      --accent: #8ab4f8;
      --bar: rgba(0,0,0,0.7);
      --bar-blur: blur(6px);
      --pageW: 960px; /* updated at runtime */
    }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body { height: 100%; overflow-x: hidden; }
    body { margin: 0; background: var(--bg); color: var(--fg);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Inter, Arial, sans-serif; }
    .topbar, .bottombar {
      position: fixed; left: 0; right: 0; z-index: 1000;
      display: flex; align-items: center; gap: 12px;
      padding: env(safe-area-inset-top) 12px 12px 12px;
      backdrop-filter: var(--bar-blur); background: var(--bar);
    }
    .topbar { top: 0; }
    .bottombar { bottom: 0; top: auto; padding: 10px 12px calc(10px + env(safe-area-inset-bottom)) 12px; justify-content: space-between; }
    .btn { border: 0; border-radius: 12px; padding: 8px 12px; background: rgba(255,255,255,0.06); color: var(--fg); font-size: 16px; cursor: pointer; }
    .btn:active { background: rgba(255,255,255,0.1); }
    .meta { font-size: 13px; color: var(--muted); } .spacer { flex: 1; }
    .pages { position: relative; width: 100%; max-width: 1200px; margin: 0 auto;
      padding-top: calc(48px + env(safe-area-inset-top)); padding-bottom: calc(70px + env(safe-area-inset-bottom)); }
    .page { display: grid; place-items: center; margin: 12px auto; width: 100%; position: relative; }
    .sheet { width: var(--pageW); }
    .sheet canvas { display: block; background: var(--pagebg); box-shadow: 0 6px 26px rgba(0,0,0,0.36); }
    .pnum { margin-top: 6px; font-size: 12px; color: var(--muted); user-select: none; }
    .overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.35); z-index: 1200; opacity: 0; pointer-events: none; transition: opacity .2s; }
    .overlay.show { opacity: 1; pointer-events: auto; }
    .drawer { position: fixed; top: 0; bottom: 0; right: 0; width: min(88vw, 380px);
      z-index: 1300; background: #121316; border-left: 1px solid #202124; transform: translateX(100%); transition: transform .25s; display: flex; flex-direction: column; }
    .drawer.open { transform: translateX(0); }
    .drawer header { padding: 16px; border-bottom: 1px solid #202124; font-weight: 600; }
    .drawer .toc { flex: 1; overflow: auto; padding: 6px 8px 16px 8px; }
    .toc button { width: 100%; text-align: left; padding: 10px 12px; margin: 6px 4px; background: transparent; color: var(--fg);
      border: 1px solid #202124; border-radius: 10px; font-size: 15px; cursor: pointer; }
    .progress { position: fixed; left: 0; right: 0; bottom: 0; height: 3px; background: rgba(255,255,255,0.08); z-index: 900; transform: translateY(-3px); }
    .progress > span { display: block; height: 100%; width: 0; background: var(--accent); transition: width .2s; }
    .dbg { position: absolute; top: 4px; left: 4px; font-size: 10px; background: rgba(0,0,0,0.55); padding: 4px 6px; border-radius: 6px; display: none; }
    .page.showdbg .dbg { display: block; }

    /* Bigger, smoother slider that "waits" */
    .zoom-pack { display: flex; align-items: center; gap: 10px; }
    input[type="range"] {
      width: clamp(260px, 42vw, 520px);
      height: 6px;
      background: transparent;
      -webkit-appearance: none;
      appearance: none;
      cursor: pointer;
      touch-action: none;
    }
    input[type="range"]::-webkit-slider-runnable-track {
      height: 6px; background: rgba(255,255,255,0.25); border-radius: 3px;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none; appearance: none;
      width: 18px; height: 18px; border-radius: 50%;
      background: var(--accent); margin-top: -6px;
      box-shadow: 0 0 0 3px rgba(0,0,0,0.2);
    }
    input[type="range"]::-moz-range-track {
      height: 6px; background: rgba(255,255,255,0.25); border-radius: 3px;
    }
    input[type="range"]::-moz-range-thumb {
      width: 18px; height: 18px; border: 0; border-radius: 50%; background: var(--accent);
      box-shadow: 0 0 0 3px rgba(0,0,0,0.2);
    }
  </style>
</head>
<body>
  <div class="topbar">
    <button id="menuBtn" class="btn">☰ Меню</button>
    <div class="meta" id="pageMeta">Стр. — / —</div>
    <div class="spacer"></div>
    <div class="meta" id="zoomMeta">100%</div>
    <button id="dbgBtn" class="btn" title="Показать отладку">D</button>
  </div>
  <div class="bottombar">
    <div class="zoom-pack">
      <button id="zoomOut" class="btn">−</button>
      <input id="zoomSlider" type="range" min="60" max="220" value="100" step="1">
      <button id="zoomIn" class="btn">+</button>
    </div>
  </div>
  <div class="pages" id="pages"></div>
  <div class="progress"><span id="progressBar"></span></div>
  <div class="overlay" id="overlay"></div>
  <aside class="drawer" id="drawer">
    <header>Содержание<div class="meta">Коснитесь главы для перехода</div></header>
    <div class="toc" id="tocList"></div>
  </aside>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.worker.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.worker.min.js';

    const PDF_URL = 'History_Climate.pdf';
    const pagesEl = document.getElementById('pages');
    const pageMetaEl = document.getElementById('pageMeta');
    const progressBar = document.getElementById('progressBar');
    const menuBtn = document.getElementById('menuBtn');
    const drawer = document.getElementById('drawer');
    const overlay = document.getElementById('overlay');
    const tocList = document.getElementById('tocList');
    const zoomSlider = document.getElementById('zoomSlider');
    const zoomInBtn = document.getElementById('zoomIn');
    const zoomOutBtn = document.getElementById('zoomOut');
    const zoomMeta = document.getElementById('zoomMeta');
    const dbgBtn = document.getElementById('dbgBtn');

    let pdfDoc = null, totalPages = 0;
    let dpr = window.devicePixelRatio || 1;
    let userScale = 1.0; // 100% = baseline viewport width
    let baselineW = 960;  // captured at load; updated only if viewport width changes significantly
    let pageMetaCache = {}; // pageNum -> {w,h,page}
    let renderTasks = {};   // pageNum -> renderTask
    let resizeTimer = null;
    let isSliding = false;
    let idleZoomTimer = null;
    let showDebug = false;

    const tocEntries = [
      { title: 'Введение', page: 2 },
      { title: 'Глава 1. Климат и история', page: 4 },
      { title: 'Глава 2. Эти таинственные шумеры', page: 36 },
      { title: 'Глава 3. Убейдцы и шумеры', page: 70 },
      { title: 'Глава 4. Конец периода Джемдет-Наср.', page: 109 },
      { title: 'Глава 5. Войны номов', page: 131 },
      { title: 'Глава 6. Расцвет и гибель Аккадского царства', page: 149 },
      { title: 'Глава 7. Возвышение Ура и появление амореев', page: 165 },
      { title: 'Глава 8. Ближний Восток в ХVI-ХIV веках до н. э.', page: 192 },
      { title: 'Глава 9. Коллапс бронзового века', page: 217 },
      { title: 'Глава 10. Современные изменения климата', page: 253 }
    ];

    tocEntries.forEach(ent => {
      const b = document.createElement('button'); b.textContent = ent.title;
      b.addEventListener('click', () => { const t = document.querySelector('[data-page="' + ent.page + '"]'); if (t) t.scrollIntoView({behavior:'smooth', block:'start'}); closeDrawer(); });
      tocList.appendChild(b);
    });

    function getVVWidth() {
      return Math.floor((window.visualViewport && window.visualViewport.width) || document.documentElement.clientWidth);
    }

    function applyPageWidth() {
      const cssW = Math.round(baselineW * userScale);
      document.documentElement.style.setProperty('--pageW', cssW + 'px');
      // Update skeleton heights if we already know metas
      document.querySelectorAll('.page').forEach(p => {
        const pageNum = parseInt(p.dataset.page, 10);
        const meta = pageMetaCache[pageNum];
        if (!meta) return;
        const h = Math.round(cssW * (meta.h / meta.w));
        const sheet = p.querySelector('.sheet');
        if (sheet) sheet.style.height = h + 'px';
      });
      return cssW;
    }

    function openDrawer() { overlay.classList.add('show'); drawer.classList.add('open'); setTimeout(() => rerenderVisible(false), 80); }
    function closeDrawer() { overlay.classList.remove('show'); drawer.classList.remove('open'); setTimeout(() => rerenderVisible(false), 80); }
    menuBtn.addEventListener('click', () => (drawer.classList.contains('open') ? closeDrawer() : openDrawer()));
    overlay.addEventListener('click', closeDrawer);
    window.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeDrawer(); });

    dbgBtn.addEventListener('click', () => {
      showDebug = !showDebug;
      document.querySelectorAll('.page').forEach(p => p.classList.toggle('showdbg', showDebug));
    });

    pdfjsLib.getDocument(PDF_URL).promise.then(async pdf => {
      pdfDoc = pdf; totalPages = pdf.numPages;

      // Capture baseline based on initial viewport width
      baselineW = Math.min(1200, Math.max(320, getVVWidth()));
      applyPageWidth();

      for (let i = 1; i <= totalPages; i++) {
        const holder = document.createElement('div'); holder.className = 'page'; holder.dataset.page = String(i);
        const dbg = document.createElement('div'); dbg.className = 'dbg'; dbg.id = 'dbg'+i; holder.appendChild(dbg);
        const sheet = document.createElement('div'); sheet.className = 'sheet';
        const canvas = document.createElement('canvas'); canvas.id = 'p' + i; sheet.appendChild(canvas);
        holder.appendChild(sheet);
        const caption = document.createElement('div'); caption.className = 'pnum'; caption.textContent = 'Страница ' + i; holder.appendChild(caption);
        pagesEl.appendChild(holder);
      }

      // Preflight metas to set skeleton heights so late pages (e.g., Chapter 10) have space and render reliably.
      preflightMetas();

      observeAndRender();
      updateProgress(); updateMetaFromViewport();
    }).catch(err => console.error('PDF load error:', err));

    // Pre-compute page metas progressively and set skeleton heights
    async function preflightMetas() {
      const cssW = Math.round(baselineW * userScale);
      for (let i = 1; i <= totalPages; i++) {
        if (!pageMetaCache[i]) {
          const meta = await ensurePageMeta(i);
          const h = Math.round(cssW * (meta.h / meta.w));
          const sheet = document.querySelector('[data-page="'+i+'"] .sheet');
          if (sheet) sheet.style.height = h + 'px';
          // Allow UI to breathe
          await new Promise(r => setTimeout(r, 0));
        }
      }
    }

    let io = null;
    function observeAndRender() {
      if (io) io.disconnect();
      io = new IntersectionObserver(async (entries) => {
        for (const entry of entries) {
          if (!entry.isIntersecting) continue;
          const pageIndex = parseInt(entry.target.dataset.page, 10);
          const canvas = entry.target.querySelector('canvas');
          if (canvas.dataset.rendered === '1' || canvas.dataset.rendering === '1') continue;
          await renderPage(pageIndex, canvas);
        }
      }, { root: null, rootMargin: '2000px 0px', threshold: 0.01 });
      document.querySelectorAll('.page').forEach(p => io.observe(p));
    }

    async function ensurePageMeta(pageNum) {
      if (pageMetaCache[pageNum]) return pageMetaCache[pageNum];
      const page = await pdfDoc.getPage(pageNum);
      const vp = page.getViewport({ scale: 1 });
      const meta = { w: vp.width, h: vp.height, page: page };
      pageMetaCache[pageNum] = meta;
      return meta;
    }

    async function renderPage(pageNum, canvas) {
      const meta = await ensurePageMeta(pageNum);
      const cssW = Math.round(baselineW * userScale);
      const cssH = Math.round(cssW * (meta.h / meta.w));
      const pxW = Math.floor(cssW * dpr);
      const pxH = Math.floor(cssH * dpr);

      // Cancel any in-flight render before starting a new one
      if (renderTasks[pageNum]) { try { renderTasks[pageNum].cancel(); } catch(e) {} }

      if (canvas.width !== pxW || canvas.height !== pxH) { canvas.width = pxW; canvas.height = pxH; }
      canvas.style.width = cssW + 'px'; canvas.style.height = cssH + 'px';

      const ctx = canvas.getContext('2d', { alpha: false });
      ctx.save(); ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.restore();

      const viewport = meta.page.getViewport({ scale: cssW / meta.w });
      canvas.dataset.rendering = '1'; canvas.dataset.rendered = '0';
      const task = meta.page.render({ canvasContext: ctx, viewport, transform: dpr !== 1 ? [dpr,0,0,dpr,0,0] : null });
      renderTasks[pageNum] = task;

      try {
        await task.promise;
        canvas.dataset.rendered = '1';
      } catch (e) {
        console.warn('Render error on page', pageNum, e && e.message);
      } finally {
        canvas.dataset.rendering = '0';
        if (renderTasks[pageNum] === task) delete renderTasks[pageNum];
      }

      const dbg = document.getElementById('dbg'+pageNum);
      if (dbg) dbg.textContent = `p${pageNum} meta:${Math.round(meta.w)}×${Math.round(meta.h)} css:${cssW}×${cssH} dpr:${dpr}`;

      updateProgress(); updateMetaFromViewport();
    }

    function rerenderVisible(forceAll=false) {
      const pages = document.querySelectorAll('.page');
      const vh = window.innerHeight;
      pages.forEach(p => {
        const r = p.getBoundingClientRect();
        const near = r.top < vh*2 && r.bottom > -vh*1;
        if (near || forceAll) {
          const pageNum = parseInt(p.dataset.page, 10);
          const canvas = p.querySelector('canvas');
          canvas.dataset.rendered = '0';
          renderPage(pageNum, canvas);
        }
      });
    }

    // Zoom handling — "wait" behavior
    function commitZoom() {
      applyPageWidth();
      rerenderVisible(true);
    }

    function setUserScaleFromSlider(v) {
      userScale = Math.max(0.6, Math.min(2.2, v / 100));
      zoomMeta.textContent = Math.round(userScale * 100) + '%';
      // Update skeleton sizes immediately so layout looks right while sliding,
      // but delay heavy re-render until user stops moving.
      applyPageWidth();
      clearTimeout(idleZoomTimer);
      idleZoomTimer = setTimeout(() => { if (!isSliding) commitZoom(); }, 300);
    }

    // Pointer-aware controls so we only commit on release
    zoomSlider.addEventListener('pointerdown', () => { isSliding = true; });
    zoomSlider.addEventListener('pointerup', () => { isSliding = false; commitZoom(); });
    zoomSlider.addEventListener('pointercancel', () => { isSliding = false; commitZoom(); });
    zoomSlider.addEventListener('change', (e) => { setUserScaleFromSlider(parseInt(e.target.value,10)); commitZoom(); });
    zoomSlider.addEventListener('input', (e) => setUserScaleFromSlider(parseInt(e.target.value,10)));

    zoomInBtn.addEventListener('click', () => { const v = Math.min(220, parseInt(zoomSlider.value,10) + 5); zoomSlider.value = v; setUserScaleFromSlider(v); commitZoom(); });
    zoomOutBtn.addEventListener('click', () => { const v = Math.max(60, parseInt(zoomSlider.value,10) - 5); zoomSlider.value = v; setUserScaleFromSlider(v); commitZoom(); });

    // Only recompute baseline width when viewport width changes by a lot
    let lastVVW = getVVWidth();
    function handleViewportResize() {
      const now = getVVWidth();
      if (Math.abs(now - lastVVW) < 120) return; // ignore tiny changes from scrollbars
      lastVVW = now;
      baselineW = Math.min(1200, Math.max(320, now));
      commitZoom();
    }
    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(handleViewportResize, 120);
      });
    } else {
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(handleViewportResize, 120);
      });
    }

    function updateProgress() {
      const scrollY = window.scrollY || document.documentElement.scrollTop || 0;
      const full = document.documentElement.scrollHeight - window.innerHeight;
      const percent = full > 0 ? Math.max(0, Math.min(100, Math.round(scrollY / full * 100))) : 0;
      progressBar.style.width = percent + '%';
    }
    function updateMetaFromViewport() {
      const pages = document.querySelectorAll('.page');
      let bestPage = 1, bestDist = Infinity;
      const viewportTop = 0;
      pages.forEach(p => {
        const r = p.getBoundingClientRect();
        const dist = Math.abs(r.top - viewportTop);
        if (dist < bestDist) { bestDist = dist; bestPage = parseInt(p.dataset.page, 10); }
      });
      pageMetaEl.textContent = 'Стр. ' + bestPage + ' / ' + totalPages;
    }
    window.addEventListener('scroll', () => { updateProgress(); updateMetaFromViewport(); }, {passive:true});
  </script>
</body>
</html>

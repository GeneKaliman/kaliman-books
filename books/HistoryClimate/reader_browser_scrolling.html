<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PDF Reader — History_Climate.pdf</title>
  <style>
    :root {
      --bg: #0b0c0f;
      --panel: #121419;
      --text: #e7e9ee;
      --muted: #9aa3b2;
      --accent: #5aa2ff;
      --reader-font-size: 18px; /* for Reader Mode */
      --shadow: 0 8px 20px rgba(0,0,0,0.35);
    }
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    /* Top bar */
    .topbar {
      position: sticky;
      top: 0;
      z-index: 20;
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 12px;
      background: linear-gradient(180deg, #0f1218 0%, #0b0c0f 100%);
      border-bottom: 1px solid #1d2230;
      backdrop-filter: blur(8px);
    }
    .brand {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 600;
      letter-spacing: 0.2px;
      white-space: nowrap;
    }
    .brand .dot {
      width: 10px; height: 10px; border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 10px var(--accent);
    }
    .spacer { flex: 1; }

    .control {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .select, .button, .range, .input {
      background: var(--panel);
      color: var(--text);
      border: 1px solid #242a3a;
      box-shadow: var(--shadow);
      border-radius: 10px;
      padding: 8px 10px;
      outline: none;
    }
    .select { padding-right: 34px; }
    .button {
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease;
    }
    .button:hover {
      background: #171b24;
      border-color: #2b3450;
    }
    .range {
      appearance: none;
      width: 180px;
      height: 34px;
      padding: 0 8px;
    }
    .range::-webkit-slider-runnable-track {
      height: 4px; border-radius: 999px; background: #2b3346;
    }
    .range::-webkit-slider-thumb {
      -webkit-appearance: none; width: 18px; height: 18px; border-radius: 50%;
      background: var(--accent);
      margin-top: -7px;
      box-shadow: 0 0 0 4px rgba(90,162,255,0.2);
      cursor: pointer;
    }
    .range::-moz-range-track { height: 4px; border-radius: 999px; background: #2b3346; }
    .range::-moz-range-thumb {
      width: 18px; height: 18px; border-radius: 50%;
      background: var(--accent);
      border: none;
      box-shadow: 0 0 0 4px rgba(90,162,255,0.2);
      cursor: pointer;
    }

    .viewer {
      display: grid;
      grid-template-columns: 1fr;
      gap: 18px;
      padding: 12px;
      max-width: 1100px;
      margin: 0 auto;
      overflow-x: hidden; /* prevent horizontal scroll ever */
    }

    .page {
      position: relative;
      display: grid;
      place-items: center;
      background: #0e1117;
      border: 1px solid #1b2230;
      border-radius: 14px;
      padding: 10px;
      box-shadow: var(--shadow);
    }
    canvas {
      width: 100% !important;  /* fit-to-width */
      height: auto !important;
      display: block;
      border-radius: 8px;
      background: white;
    }
    .pagenum {
      position: absolute;
      right: 14px;
      bottom: 12px;
      background: rgba(0,0,0,0.55);
      color: #fff;
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 12px;
    }

    /* Reader (text) mode */
    .reader {
      max-width: 900px;
      margin: 12px auto;
      padding: 0 16px 40px;
      line-height: 1.7;
      display: none; /* hidden by default */
    }
    .reader.active { display: block; }
    .reader article {
      font-size: var(--reader-font-size);
      color: #e9ecf3;
      text-rendering: optimizeLegibility;
    }
    .reader h2, .reader h3 {
      margin-top: 2.2em;
      margin-bottom: 0.6em;
      line-height: 1.25;
      color: #f0f4ff;
    }
    .reader p {
      margin: 0.6em 0;
    }
    .reader hr {
      border: none;
      height: 1px;
      background: #222a3a;
      margin: 1.2em 0;
    }

    .hint {
      color: var(--muted);
      font-size: 13px;
      margin-left: 8px;
    }

    .hidden { display: none !important; }
    .toc-empty { color: var(--muted); }

    .footer {
      color: var(--muted);
      font-size: 12px;
      text-align: center;
      padding: 30px 0 80px;
    }

    .backtotop {
      position: fixed;
      right: 14px;
      bottom: 16px;
      z-index: 15;
      border-radius: 999px;
      border: 1px solid #223048;
      background: #121a28;
      color: #eaf0ff;
      padding: 10px 14px;
      cursor: pointer;
      box-shadow: var(--shadow);
    }
    .backtotop:hover { background: #0f1521; }
  </style>
</head>
<body>
  <header class="topbar">
    <div class="brand">
      <span class="dot"></span>
      <span>PDF Reader</span>
    </div>

    <!-- Chapter jump (TOC) -->
    <div class="control">
      <label for="toc">Chapters:</label>
      <select id="toc" class="select">
        <option disabled selected>Loading…</option>
      </select>
      <span id="tocHint" class="hint"></span>
    </div>

    <div class="spacer"></div>

    <!-- Mode toggle -->
    <div class="control">
      <button id="modeBtn" class="button" title="Toggle Reader (text) mode">Reader mode: Off</button>
      <span class="hint">Text-only mode for adjustable font size</span>
    </div>

    <!-- Font size slider (Reader Mode) -->
    <div class="control" id="fontCtrl" style="display:none;">
      <label for="fontRange">Font</label>
      <input id="fontRange" class="range" type="range" min="14" max="28" step="1" value="18" />
      <span id="fontVal" class="hint">18px</span>
    </div>
  </header>

  <!-- Canvas page viewer -->
  <main id="viewer" class="viewer" aria-label="PDF pages"></main>

  <!-- Reader (reflowed text) -->
  <section id="reader" class="reader" aria-label="Reflowed text">
    <article id="readerContent">
      <p class="toc-empty">Loading text…</p>
    </article>
  </section>

  <button id="backToTop" class="backtotop" title="Back to top">↑ Top</button>

  <div class="footer">Built with <a href="https://mozilla.github.io/pdf.js/" target="_blank" rel="noreferrer" style="color:#8fb6ff;">PDF.js</a>. File: <code>History_Climate.pdf</code></div>

  <!-- PDF.js (legacy script build for best compatibility with local files) -->
  <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js"></script>

  <script>
    (function() {
      const pdfjsLib = window['pdfjs-dist/build/pdf'];
      if (!pdfjsLib) {
        alert('Failed to load PDF.js. Please check your internet connection.');
        return;
      }
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js';

      // ===== Config =====
      const PDF_URL = 'History_Climate.pdf'; // same folder as this HTML
      const viewerEl = document.getElementById('viewer');
      const readerEl = document.getElementById('reader');
      const readerContent = document.getElementById('readerContent');
      const tocSelect = document.getElementById('toc');
      const tocHint = document.getElementById('tocHint');
      const modeBtn = document.getElementById('modeBtn');
      const fontCtrl = document.getElementById('fontCtrl');
      const fontRange = document.getElementById('fontRange');
      const fontVal = document.getElementById('fontVal');
      const backToTop = document.getElementById('backToTop');

      let pdfDoc = null;
      let pageCount = 0;
      let pagePlaceholders = [];
      let pageTextCache = new Map(); // pageNumber -> text (string)
      let observer = null;
      let inReader = false;

      // ===== Helpers =====
      function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
      function scrollToEl(el) { el?.scrollIntoView({ behavior: 'smooth', block: 'start' }); }
      function fitWidthScale(page, containerWidth) {
        const viewport = page.getViewport({ scale: 1 });
        return containerWidth / viewport.width;
      }
      function createPagePlaceholder(n) {
        const pageDiv = document.createElement('div');
        pageDiv.className = 'page';
        pageDiv.id = 'page-' + n;

        const canvas = document.createElement('canvas');
        canvas.setAttribute('data-page-number', n);
        canvas.role = 'img';
        canvas.ariaLabel = 'Page ' + n;
        pageDiv.appendChild(canvas);

        const badge = document.createElement('div');
        badge.className = 'pagenum';
        badge.textContent = n + ' / ' + pageCount;
        pageDiv.appendChild(badge);

        viewerEl.appendChild(pageDiv);
        return { pageDiv, canvas };
      }

      async function renderPage(n) {
        if (!pdfDoc) return;
        const { pageDiv, canvas } = pagePlaceholders[n - 1] ?? {};
        if (!canvas) return;
        // If already rendered, skip (canvas has data-rt flag)
        if (canvas.dataset.rendered === '1') return;

        const page = await pdfDoc.getPage(n);
        const containerWidth = viewerEl.clientWidth - 24; // account for padding
        const scale = fitWidthScale(page, containerWidth);
        const viewport = page.getViewport({ scale });

        const context = canvas.getContext('2d');
        const outputScale = window.devicePixelRatio || 1;
        canvas.width = Math.floor(viewport.width * outputScale);
        canvas.height = Math.floor(viewport.height * outputScale);
        canvas.style.width = viewport.width + 'px';
        canvas.style.height = viewport.height + 'px';

        const transform = outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : null;
        await page.render({ canvasContext: context, viewport, transform }).promise;
        canvas.dataset.rendered = '1';

        // Pre-cache text layer (used for Reader Mode + TOC fallback)
        if (!pageTextCache.has(n)) {
          const textContent = await page.getTextContent({ includeMarkedContent: true });
          const text = textContent.items.map(i => i.str).join(' ').replace(/\s{2,}/g, ' ').trim();
          pageTextCache.set(n, text);
        }
      }

      function setupObserver() {
        if (observer) observer.disconnect();
        observer = new IntersectionObserver((entries) => {
          entries.forEach(e => {
            if (e.isIntersecting) {
              const canvas = e.target.querySelector('canvas');
              const n = parseInt(canvas?.dataset.pageNumber, 10);
              if (Number.isFinite(n)) renderPage(n);
            }
          });
        }, { rootMargin: '600px 0px' }); // pre-render ahead
        pagePlaceholders.forEach(({ pageDiv }) => observer.observe(pageDiv));
      }

      async function buildTOC() {
        let outline = await pdfDoc.getOutline();
        let entries = [];

        // If PDF Outline exists, map to page numbers
        if (Array.isArray(outline) && outline.length) {
          const walk = async (items) => {
            for (const item of items) {
              let title = (item.title || '').trim();
              let pageIndex = null;
              if (item.dest) {
                try {
                  const dest = await pdfDoc.getDestination(item.dest);
                  if (dest) {
                    const ref = dest[0];
                    pageIndex = await pdfDoc.getPageIndex(ref);
                  }
                } catch {}
              }
              if (title && pageIndex !== null) {
                entries.push({ title, page: pageIndex + 1 });
              }
              if (item.items && item.items.length) await walk(item.items);
            }
          };
          await walk(outline);
        }

        // Fallback: detect simple "Глава" / "Chapter" headings from text cache
        if (!entries.length) {
          tocHint.textContent = 'No embedded outline; using detected headings.';
          const HEAD_RE = /\b(Глава|Chapter)\s+([0-9IVXLC]+)[\.\s:-]+(.{4,80})/i;
          const firstN = Math.min(pageCount, 60); // look at first 60 pages
          for (let n = 1; n <= firstN; n++) {
            // ensure text cached
            if (!pageTextCache.has(n)) {
              try {
                const page = await pdfDoc.getPage(n);
                const textContent = await page.getTextContent({ includeMarkedContent: true });
                const text = textContent.items.map(i => i.str).join(' ').replace(/\s{2,}/g, ' ').trim();
                pageTextCache.set(n, text);
              } catch {}
            }
            const text = pageTextCache.get(n) || '';
            const m = text.match(HEAD_RE);
            if (m) {
              const short = (m[0] || '').substring(0, 90);
              entries.push({ title: short, page: n });
            }
          }
        } else {
          tocHint.textContent = '';
        }

        // Populate <select>
        tocSelect.innerHTML = '';
        if (!entries.length) {
          tocSelect.innerHTML = '<option disabled selected>(No chapters found)</option>';
          tocSelect.disabled = true;
          return;
        }
        tocSelect.disabled = false;
        const firstOpt = document.createElement('option');
        firstOpt.textContent = 'Jump to chapter…';
        firstOpt.disabled = true;
        firstOpt.selected = true;
        tocSelect.appendChild(firstOpt);

        entries.forEach(({ title, page }, idx) => {
          const opt = document.createElement('option');
          opt.value = String(page);
          opt.textContent = `${title}`;
          tocSelect.appendChild(opt);
        });

        tocSelect.addEventListener('change', (e) => {
          const page = parseInt(e.target.value, 10);
          const el = document.getElementById('page-' + page);
          if (el) scrollToEl(el);
        });
      }

      async function buildReaderContent() {
        // Generate simple text-only content by concatenating page text.
        // Also insert lightweight headings if "Глава" / "Chapter" is detected.
        readerContent.innerHTML = '';
        const HEAD_RE = /\b(Глава|Chapter)\s+([0-9IVXLC]+)[\.\s:-]+(.{4,100})/i;

        for (let n = 1; n <= pageCount; n++) {
          if (!pageTextCache.has(n)) {
            try {
              const page = await pdfDoc.getPage(n);
              const tc = await page.getTextContent({ includeMarkedContent: true });
              const text = tc.items.map(i => i.str).join(' ').replace(/\s{2,}/g, ' ').trim();
              pageTextCache.set(n, text);
            } catch { pageTextCache.set(n, ''); }
          }
          const raw = pageTextCache.get(n);
          if (!raw) continue;

          // Insert a page divider
          const hr = document.createElement('hr');
          readerContent.appendChild(hr);

          const m = raw.match(HEAD_RE);
          if (m) {
            const h = document.createElement('h2');
            h.textContent = m[0];
            readerContent.appendChild(h);
          }

          // Split on sentence-ish boundaries for readability
          const para = document.createElement('p');
          para.textContent = raw;
          readerContent.appendChild(para);
        }
      }

      function setReaderMode(on) {
        inReader = !!on;
        modeBtn.textContent = 'Reader mode: ' + (inReader ? 'On' : 'Off');
        fontCtrl.style.display = inReader ? '' : 'none';
        readerEl.classList.toggle('active', inReader);
        viewerEl.style.display = inReader ? 'none' : 'grid';
        if (inReader && !readerContent.dataset.ready) {
          buildReaderContent().then(() => { readerContent.dataset.ready = '1'; });
        }
      }

      // Back to top
      backToTop.addEventListener('click', () => window.scrollTo({ top: 0, behavior: 'smooth' }));

      // Reader font size
      const applyFont = (v) => {
        document.documentElement.style.setProperty('--reader-font-size', v + 'px');
        fontVal.textContent = v + 'px';
      };
      fontRange.addEventListener('input', (e) => applyFont(e.target.value));
      applyFont(fontRange.value);

      // Mode toggle
      modeBtn.addEventListener('click', () => setReaderMode(!inReader));

      // Handle resize: re-render visible pages to maintain fit-to-width
      let rAF = null;
      window.addEventListener('resize', () => {
        if (inReader) return;
        if (rAF) cancelAnimationFrame(rAF);
        rAF = requestAnimationFrame(async () => {
          // Clear rendered flags so pages re-render with new width
          pagePlaceholders.forEach(({ pageDiv }) => {
            const canvas = pageDiv.querySelector('canvas');
            if (canvas) {
              canvas.dataset.rendered = '0';
              canvas.width = 0; canvas.height = 0;
            }
          });
          setupObserver();
          // Immediately render first couple of pages
          for (let n = 1; n <= Math.min(4, pageCount); n++) renderPage(n);
        });
      });

      // ===== Boot =====
      (async function init() {
        try {
          const loadingTask = pdfjsLib.getDocument({
            url: PDF_URL,
            disableAutoFetch: false,
            enableXfa: false,
          });
          pdfDoc = await loadingTask.promise;
        } catch (err) {
          console.error(err);
          alert('Could not open "' + PDF_URL + '". Place this HTML file and the PDF in the same folder, then reload.');
          return;
        }

        pageCount = pdfDoc.numPages;
        // Create placeholders and lazy-render
        pagePlaceholders = Array.from({ length: pageCount }, (_, i) => createPagePlaceholder(i + 1));
        setupObserver();
        // Render top pages immediately
        for (let n = 1; n <= Math.min(4, pageCount); n++) renderPage(n);

        // Build TOC
        buildTOC();
      })();
    })();
  </script>
</body>
</html>

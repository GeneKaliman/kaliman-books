<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Браузерный ридер — История климата (fast)</title>
  <style>
    :root{
      --bg:#0b0b0c; --fg:#e7e7ea; --muted:#9aa0a6; --accent:#8ab4f8; --bar:rgba(0,0,0,.7);
      --pageW: 960px;
    }
    *{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
    html,body{ height:100%; overflow-x:auto; touch-action: pan-x pan-y pinch-zoom; overscroll-behavior: contain; }
    body{ margin:0; background:var(--bg); color:var(--fg);
      font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Inter,Arial,sans-serif; }

    .topbar{
      position:fixed; inset:0 0 auto 0; z-index:1000;
      display:flex; align-items:center; gap:10px;
      padding: env(safe-area-inset-top) 10px 10px 10px;
      backdrop-filter: blur(6px); background:var(--bar);
      pointer-events:auto; transform-origin:0 0;
    }
    .btn{ border:0; border-radius:12px; padding:8px 12px; background:rgba(255,255,255,.06); color:var(--fg); font-size:16px; cursor:pointer; }
    .btn:active{ background:rgba(255,255,255,.1); }
    .spacer{ flex:1; }

    .pages{ position:relative; width:100%; max-width:1200px; margin:0 auto;
      padding-top: calc(48px + env(safe-area-inset-top)); padding-bottom: 24px; }
    .page{ margin:12px 0; width:100%; }
    .sheet{ width: var(--pageW); margin: 0 auto; }
    .sheet canvas{ display:block; background:#fff; box-shadow: 0 6px 26px rgba(0,0,0,.36); }

    .overlay{ position:fixed; inset:0; background:rgba(0,0,0,.35);
      z-index:1200; opacity:0; pointer-events:none; transition:opacity .2s; }
    .overlay.show{ opacity:1; pointer-events:auto; }
    .drawer{ position:fixed; top:0; bottom:0; right:0; width:min(88vw,380px);
      z-index:1300; background:#121316; border-left:1px solid #202124;
      transform:translateX(100%); transition:transform .25s; display:flex; flex-direction:column; }
    .drawer.open{ transform:translateX(0); }
    .drawer header{ padding:16px; border-bottom:1px solid #202124; font-weight:600; }
    .drawer .toc{ flex:1; overflow:auto; padding:6px 8px 16px 8px; }
    .toc button{ width:100%; text-align:left; padding:10px 12px; margin:6px 4px;
      background:transparent; color:var(--fg); border:1px solid #202124; border-radius:10px; font-size:15px; cursor:pointer; }

    .progress{ position:fixed; left:0; right:0; bottom:0; height:3px; background:rgba(255,255,255,.08);
      z-index:900; transform: translateY(-3px); transform-origin: 0 100%; }
    .progress > span{ display:block; height:100%; width:0; background:var(--accent); transition:width .2s; }

    #spinner{ position:fixed; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center;
      z-index:2000; background:rgba(0,0,0,.5); color:var(--fg); font-size:16px; pointer-events:none; transition:opacity .3s; text-align:center; padding:0 12px;}
    #spinner.hidden{ opacity:0; pointer-events:none; display:none; }
    #spinner .icon{ width:48px; height:48px; border:4px solid rgba(255,255,255,.4); border-top-color:var(--accent);
      border-radius:50%; animation:spin 1s linear infinite; margin-bottom:12px; }
    @keyframes spin{ from{ transform:rotate(0deg);} to{ transform:rotate(360deg);} }
  </style>
</head>
<body>
  <div class="topbar" id="topbar">
    <button id="menuBtn" class="btn">☰ Меню</button>
    <div class="spacer"></div>
    <button id="resetFit" class="btn" title="Сброс под текущую ориентацию">Сброс</button>
  </div>

  <div class="pages" id="pages"></div>
  <div class="progress" id="progress"><span id="progressBar"></span></div>

  <div class="overlay" id="overlay"></div>
  <aside class="drawer" id="drawer">
    <header>Содержание<div class="meta">Коснитесь главы для перехода</div></header>
    <div class="toc" id="tocList"></div>
  </aside>

  <div id="spinner"><div class="icon"></div><div id="spinText">Пожалуйста, подождите…</div></div>

  <script src="https://unpkg.com/pdfjs-dist@4.4.168/build/pdf.min.js"></script>
  <script>
    const PDF_URL = './History_Climate.pdf';

    const pagesEl = document.getElementById('pages');
    const menuBtn = document.getElementById('menuBtn');
    const drawer = document.getElementById('drawer');
    const overlay = document.getElementById('overlay');
    const spinner = document.getElementById('spinner');
    const spinText = document.getElementById('spinText');
    const progressBar = document.getElementById('progressBar');
    const resetFitBtn = document.getElementById('resetFit');
    const topbarEl = document.getElementById('topbar');

    let pdfDoc=null,totalPages=0,baselineW=960,lastVVW=0,lastScale=1;
    let pageMetaCache={},renderTasks={},vvScale=1,pageAspect=0.707,menuVisible=true;
    let firstRenderTimer=null;

    function getVVWidth(){ return Math.floor((window.visualViewport && window.visualViewport.width) || document.documentElement.clientWidth); }
    function getVVHeight(){ return Math.floor((window.visualViewport && window.visualViewport.height) || window.innerHeight); }
    function effectiveDPR(){ vvScale = (window.visualViewport && window.visualViewport.scale) || 1; return (window.devicePixelRatio || 1) * (vvScale || 1); }

    function setPageWidth(w){
      baselineW = Math.round(w);
      document.documentElement.style.setProperty('--pageW', baselineW + 'px');
      document.querySelectorAll('.page .sheet canvas').forEach((cv)=>{
        const pn = parseInt(cv.id.replace('p',''),10);
        const meta = pageMetaCache[pn];
        const cssH = meta ? Math.round(baselineW * (meta.h/meta.w)) : Math.round(baselineW / (pageAspect||0.707));
        cv.style.width = baselineW + 'px';
        cv.style.height = cssH + 'px';
        cv.dataset.rendered = '0';
      });
    }

    function computeFitWidth(){
      const vw = getVVWidth();
      const vh = getVVHeight();
      const topH = topbarEl ? topbarEl.offsetHeight : 0;
      const bottomMargin = 80;
      const widthPortrait = vw;
      const widthLandscape = Math.min(vw, Math.max(160, (vh - topH - bottomMargin) * (pageAspect || 0.707)));
      return Math.min(1200, Math.max(160, (vh >= vw) ? widthPortrait : widthLandscape));
    }

    function setBarsVisible(show){
      menuVisible = !!show;
      topbarEl.style.display = show ? 'flex' : 'none';
      document.getElementById('progress').style.display = show ? 'block' : 'none';
      updateFixedPositions();
    }
    function toggleBars(){ setBarsVisible(!menuVisible); }

    function updateFixedPositions(){
      const vv = window.visualViewport;
      if (!vv) return;
      const x = vv.offsetLeft || 0, y = vv.offsetTop || 0, scale = vv.scale || 1;
      topbarEl.style.transform = `translate(${x}px, ${y}px) scale(${1/scale})`;
      const progressEl = document.getElementById('progress');
      progressEl.style.transform = `translate(${x}px, -3px) scale(${1/scale})`;
    }

    function snapshotWidth(){ lastVVW = getVVWidth(); setPageWidth(computeFitWidth()); }
    pagesEl.addEventListener('click', (e)=>{ if (drawer.contains(e.target) || topbarEl.contains(e.target)) return; toggleBars(); });
    menuBtn.addEventListener('click', ()=>{ drawer.classList.add('open'); overlay.classList.add('show'); });
    overlay.addEventListener('click', ()=>{ drawer.classList.remove('open'); overlay.classList.remove('show'); });
    resetFitBtn.addEventListener('click', ()=>{ setPageWidth(computeFitWidth()); rerenderVisible(); window.scrollTo({top:0, behavior:'smooth'}); });

    snapshotWidth();

    // FAST preflight: only first page meta
    async function preflightMetasLite(){
      try{
        const m1 = await ensurePageMeta(1);
        pageAspect = (m1 && m1.w && m1.h) ? (m1.w / m1.h) : pageAspect;
        // set placeholder heights for all holders based on pageAspect
        document.querySelectorAll('.page .sheet').forEach(sh=>{
          sh.style.height = Math.round(baselineW * (1 / (pageAspect || 0.707))) + 'px';
        });
        // refit once with exact aspect
        setPageWidth(computeFitWidth());
      }catch(e){ console.warn('preflight error', e); }
    }

    // build skeleton quickly (no captions page numbers)
    function buildSkeleton(n){
      const frag = document.createDocumentFragment();
      for (let i=1;i<=n;i++){
        const holder = document.createElement('div'); holder.className = 'page'; holder.dataset.page = String(i);
        const sheet = document.createElement('div'); sheet.className = 'sheet';
        const canvas = document.createElement('canvas'); canvas.id = 'p'+i; sheet.appendChild(canvas);
        holder.appendChild(sheet);
        frag.appendChild(holder);
      }
      pagesEl.appendChild(frag);
    }

    // PDF bootstrap
    (async function init(){
      try{
        pdfDoc = await pdfjsLib.getDocument(PDF_URL).promise;
        totalPages = pdfDoc.numPages;
        buildSkeleton(totalPages);
        await preflightMetasLite();
        observeAndRender();
        // spinner safety: if first page not visible in 5s, inform user but keep trying
        firstRenderTimer = setTimeout(()=>{
          if (!spinner.classList.contains('hidden')){
            spinText.textContent = 'Долго загружается… Если видите это сообщение более 10 секунд, проверьте PDF-файл и соединение.';
          }
        }, 5000);
      }catch(err){
        console.error('PDF load error:', err);
        spinText.textContent = 'Не удалось загрузить PDF. Проверьте имя файла и путь: History_Climate.pdf';
        // still hide spinner background after short pause so page remains usable
        setTimeout(()=> spinner.classList.add('hidden'), 1500);
      }
    })();

    async function ensurePageMeta(pageNum){
      if (pageMetaCache[pageNum]) return pageMetaCache[pageNum];
      const page = await pdfDoc.getPage(pageNum);
      const vp = page.getViewport({ scale:1 });
      const meta = { w: vp.width, h: vp.height, page };
      pageMetaCache[pageNum] = meta;
      if (pageNum === 1){ pageAspect = vp.width / vp.height; }
      return meta;
    }

    let io=null;
    function observeAndRender(){
      if (io) io.disconnect();
      io = new IntersectionObserver(async (entries)=>{
        for (const entry of entries){
          if (!entry.isIntersecting) continue;
          const pageIndex = parseInt(entry.target.dataset.page,10);
          const canvas = entry.target.querySelector('canvas');
          if (canvas.dataset.rendered === '1' || canvas.dataset.rendering === '1') continue;
          await renderPage(pageIndex, canvas);
        }
      }, { root:null, rootMargin:'1800px 0px', threshold:0.01 });
      document.querySelectorAll('.page').forEach(p=> io.observe(p));
    }

    async function renderPage(pageNum, canvas){
      const meta = await ensurePageMeta(pageNum);
      const cssW = baselineW;
      const cssH = Math.round(cssW * (meta.h/meta.w));
      const eff = effectiveDPR();
      const pxW = Math.floor(cssW * eff);
      const pxH = Math.floor(cssH * eff);

      if (renderTasks[pageNum]){ try{ renderTasks[pageNum].cancel(); }catch(e){} }
      if (canvas.width !== pxW || canvas.height !== pxH){ canvas.width = pxW; canvas.height = pxH; }
      canvas.style.width = cssW + 'px'; canvas.style.height = cssH + 'px';

      const ctx = canvas.getContext('2d', { alpha:false });
      ctx.save(); ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.restore();

      const viewport = meta.page.getViewport({ scale: cssW / meta.w });
      canvas.dataset.rendering = '1'; canvas.dataset.rendered = '0';
      const task = meta.page.render({ canvasContext: ctx, viewport, transform: eff !== 1 ? [eff,0,0,eff,0,0] : null });
      renderTasks[pageNum] = task;

      try{ await task.promise; canvas.dataset.rendered = '1'; }
      catch(e){ console.warn('Render error p'+pageNum, e && e.message); }
      finally{ canvas.dataset.rendering = '0'; if (renderTasks[pageNum] === task) delete renderTasks[pageNum]; }

      if (pageNum === 1 && spinner && !spinner.classList.contains('hidden')){
        clearTimeout(firstRenderTimer); firstRenderTimer = null;
        spinner.classList.add('hidden');
      }
      updateProgress();
    }

    function rerenderVisible(){
      const pages = document.querySelectorAll('.page');
      const vh = window.innerHeight;
      pages.forEach(p=>{
        const r = p.getBoundingClientRect();
        const near = r.top < vh*2 && r.bottom > -vh*1;
        if (near){
          const pageNum = parseInt(p.dataset.page,10);
          const canvas = p.querySelector('canvas');
          canvas.dataset.rendered = '0';
          renderPage(pageNum, canvas);
        }
      });
    }

    function onVVChange(){
      const vv = window.visualViewport;
      const nowW = vv ? vv.width : document.documentElement.clientWidth;
      const nowScale = vv ? vv.scale : 1;
      const widthDelta = Math.abs(nowW - lastVVW);
      const scaleDelta = Math.abs((nowScale || 1) - (lastScale || 1));
      lastVVW = nowW; lastScale = nowScale;
      if (widthDelta > 120){ setPageWidth(computeFitWidth()); rerenderVisible(); updateFixedPositions(); }
      else if (scaleDelta > 0.02){ rerenderVisible(); updateFixedPositions(); }
    }

    if (window.visualViewport){
      const schedule = (()=>{ let raf=0; return ()=>{ if (raf) return; raf = requestAnimationFrame(()=>{ raf=0; onVVChange(); }); }; })();
      window.visualViewport.addEventListener('resize', schedule);
      window.visualViewport.addEventListener('scroll', schedule);
      window.visualViewport.addEventListener('resize', updateFixedPositions);
      window.visualViewport.addEventListener('scroll', updateFixedPositions);
      updateFixedPositions();
    }else{
      window.addEventListener('resize', ()=>{ clearTimeout(window.__rt); window.__rt = setTimeout(onVVChange, 80); });
    }
    window.addEventListener('orientationchange', ()=> setTimeout(onVVChange, 220));

    function updateProgress(){
      const scrollY = window.scrollY || document.documentElement.scrollTop || 0;
      const full = document.documentElement.scrollHeight - window.innerHeight;
      const percent = full > 0 ? Math.max(0, Math.min(100, Math.round(scrollY / full * 100))) : 0;
      progressBar.style.width = percent + '%';
    }
    window.addEventListener('scroll', updateProgress, { passive:true });
  </script>
</body>
</html>

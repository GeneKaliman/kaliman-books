<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Мобильный ридер — История климата</title>
  <style>
    :root {
      --bg: #0b0b0c;
      --fg: #e7e7ea;
      --muted: #9aa0a6;
      --accent: #8ab4f8;
      --bar: rgba(0,0,0,0.7);
      --bar-blur: blur(6px);
      --overlay: rgba(0,0,0,0.55);
    }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Inter, Arial, sans-serif;
      overscroll-behavior: none;
    }

    /* Top chrome */
    .topbar {
      position: fixed; left: 0; right: 0; top: 0; z-index: 10;
      display: flex; align-items: center; gap: 12px;
      padding: env(safe-area-inset-top) 12px 12px 12px;
      backdrop-filter: var(--bar-blur);
      background: var(--bar);
      transform: translateY(-100%);
      transition: transform .25s ease;
    }
    body.chrome-visible .topbar,
    body.modal-open .topbar { transform: translateY(0); }

    .btn {
      appearance: none; border: 0; border-radius: 12px; padding: 8px 12px;
      background: rgba(255,255,255,0.06); color: var(--fg); font-size: 16px;
    }
    .btn:active { background: rgba(255,255,255,0.1); }
    .icon { font-size: 20px; line-height: 1; }

    /* Stage (no scroll; page-fit by width). We pan inside when zoomed */
    .stage {
      position: fixed; inset: 0;
      overflow: hidden;
      touch-action: none; /* we'll manage pinch/pan */
      background: var(--bg);
    }
    .pageWrap {
      position: absolute; left: 50%; top: 50%;
      transform: translate(-50%,-50%);
      will-change: transform;
    }
    canvas {
      display: block;
      background: #fff;
      max-width: 100%;
      height: auto;
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    }

    /* Tap zones for paging */
    .tapzone {
      position: fixed; top: 0; bottom: 0; width: 22%; z-index: 5;
    }
    .tap-left  { left: 0; }
    .tap-right { right: 0; }
    .tap-mid   { left: 22%; right: 22%; width: auto; }

    /* Drawer (TOC) */
    .drawer {
      position: fixed; top: 0; bottom: 0; right: 0; width: min(88vw, 380px); z-index: 20;
      background: #121316; border-left: 1px solid #202124; transform: translateX(100%);
      transition: transform .25s ease;
      display: flex; flex-direction: column;
    }
    .drawer.open { transform: translateX(0); }
    .drawer header { padding: 16px; border-bottom: 1px solid #202124; font-weight: 600; }
    .drawer .toc { flex: 1; overflow: auto; padding: 6px 8px 16px 8px; }
    .toc button {
      width: 100%; text-align: left; padding: 10px 12px; margin: 6px 4px;
      background: transparent; color: var(--fg); border: 1px solid #202124; border-radius: 10px;
      font-size: 15px;
    }
    .toc button:active { background: rgba(255,255,255,0.06); }

    .meta { font-size: 13px; color: var(--muted); }
    .spacer { flex: 1; }

    /* Bottom sliding bar (zoom + fit) */
    .bottombar {
      position: fixed; left: 0; right: 0; bottom: 0; z-index: 10;
      display: flex; align-items: center; justify-content: space-between; gap: 12px;
      padding: 10px 12px calc(10px + env(safe-area-inset-bottom)) 12px;
      backdrop-filter: var(--bar-blur);
      background: var(--bar);
      transform: translateY(100%);
      transition: transform .25s ease;
    }
    .zoom-pack { display: flex; align-items: center; gap: 8px; }
    input[type="range"] { width: 160px; }
    body.chrome-visible .bottombar,
    body.modal-open .bottombar { transform: translateY(0); }

    /* Center-tap Menu Modal */
    .modal-backdrop {
      position: fixed; inset: 0; background: var(--overlay);
      display: none; align-items: center; justify-content: center; z-index: 30;
      backdrop-filter: blur(2px);
    }
    .modal-backdrop.open { display: flex; }
    .modal {
      width: min(92vw, 520px);
      background: #17181b;
      border: 1px solid #24262b;
      border-radius: 16px;
      padding: 14px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.6);
    }
    .modal h3 { margin: 0 0 10px 0; font-size: 18px; }
    .modal .row { display: flex; gap: 8px; margin: 10px 0; }
    .modal input[type="text"], .modal input[type="number"] {
      flex: 1; padding: 10px 12px; border-radius: 10px; border: 1px solid #2a2d33; background: #111317; color: var(--fg);
      font-size: 15px;
    }
    .modal .pill { padding: 10px 12px; border-radius: 10px; border: 1px solid #2a2d33; background: #111317; color: var(--fg); }
    .modal .actions { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; }
  </style>
</head>
<body>
  <div class="topbar">
    <button id="menuBtn" class="btn"><span class="icon">☰</span> Меню</button>
    <div class="meta" id="pageMeta">Стр. — / —</div>
    <div class="spacer"></div>
    <button id="aaBtn" class="btn">Aa</button>
  </div>

  <div class="stage" id="stage">
    <div class="pageWrap" id="pageWrap">
      <canvas id="page"></canvas>
    </div>
  </div>

  <!-- Tap zones -->
  <div class="tapzone tap-left"  id="zonePrev"></div>
  <div class="tapzone tap-mid"   id="zoneToggle"></div>
  <div class="tapzone tap-right" id="zoneNext"></div>

  <!-- TOC Drawer -->
  <aside class="drawer" id="drawer">
    <header>
      Содержание
      <div class="meta">Коснитесь главы для перехода</div>
    </header>
    <div class="toc" id="tocList"></div>
  </aside>

  <!-- Center Menu Modal -->
  <div class="modal-backdrop" id="modalBackdrop">
    <div class="modal">
      <h3>Меню • <span id="modalPageMeta">Стр. — / —</span></h3>

      <div class="row">
        <input id="searchInput" type="text" placeholder="Поиск по книге…" />
        <button id="searchBtn" class="btn">Найти</button>
      </div>
      <div class="actions">
        <button id="searchPrev" class="btn">◀ Пред. совп.</button>
        <button id="searchNext" class="btn">След. совп. ▶</button>
        <span class="pill" id="searchCount">0 совпадений</span>
      </div>

      <div class="row">
        <input id="gotoInput" type="number" min="1" step="1" placeholder="№ страницы" />
        <button id="gotoBtn" class="btn">Перейти</button>
        <button id="tocBtn" class="btn">Содержание</button>
      </div>

      <div class="actions">
        <button id="closeModal" class="btn">Закрыть</button>
      </div>
    </div>
  </div>

  <!-- Bottom bar -->
  <div class="bottombar">
    <div class="zoom-pack">
      <button id="zoomOut" class="btn">−</button>
      <input id="zoomSlider" type="range" min="70" max="300" value="100" step="5">
      <button id="zoomIn" class="btn">+</button>
    </div>
    <button id="fitBtn" class="btn">Подогнать страницу</button>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.worker.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.worker.min.js';

    const PDF_URL = 'History_Climate.pdf';
    const canvas = document.getElementById('page');
    const ctx = canvas.getContext('2d');
    const menuBtn = document.getElementById('menuBtn');
    const aaBtn = document.getElementById('aaBtn');
    const pageMeta = document.getElementById('pageMeta');
    const drawer = document.getElementById('drawer');
    const tocList = document.getElementById('tocList');
    const zonePrev = document.getElementById('zonePrev');
    const zoneNext = document.getElementById('zoneNext');
    const zoneToggle = document.getElementById('zoneToggle');

    const stage = document.getElementById('stage');
    const pageWrap = document.getElementById('pageWrap');

    const modalBackdrop = document.getElementById('modalBackdrop');
    const modalPageMeta = document.getElementById('modalPageMeta');
    const searchInput = document.getElementById('searchInput');
    const searchBtn = document.getElementById('searchBtn');
    const searchPrev = document.getElementById('searchPrev');
    const searchNext = document.getElementById('searchNext');
    const searchCount = document.getElementById('searchCount');
    const gotoInput = document.getElementById('gotoInput');
    const gotoBtn = document.getElementById('gotoBtn');
    const tocBtn = document.getElementById('tocBtn');
    const closeModal = document.getElementById('closeModal');

    const zoomInBtn = document.getElementById('zoomIn');
    const zoomOutBtn = document.getElementById('zoomOut');
    const zoomSlider = document.getElementById('zoomSlider');
    const fitBtn = document.getElementById('fitBtn');

    let pdfDoc = null, pageNum = 1, totalPages = 0;
    let originalPageWidth = null;
    let showChrome = false;
    let mode = localStorage.getItem('mMode') || 'fit'; // 'fit' or 'manual'

    // Zoom/Pan state
    let baseScale = 1;        // width-fit scale (recalculated on resize)
    let userScale = 1;        // additional zoom from slider/pinch (1 = 100%)
    let panX = 0, panY = 0;   // in CSS pixels
    let lastGesture = 0;

    // Simple TOC
    const tocEntries = [
      { title: 'Введение', page: 2 },
      { title: 'Глава 1. Климат и история', page: 4 },
      { title: 'Глава 2. Эти таинственные шумеры', page: 36 },
      { title: 'Глава 3. Убейдцы и шумеры', page: 70 },
      { title: 'Глава 4. Конец периода Джемдет-Наср.', page: 109 },
      { title: 'Глава 5. Войны номов', page: 131 },
      { title: 'Глава 6. Расцвет и гибель Аккадского царства', page: 149 },
      { title: 'Глава 7. Возвышение Ура и появление амореев', page: 165 },
      { title: 'Глава 8. Ближний Восток в ХVI-ХIV веках до н. э.', page: 192 },
      { title: 'Глава 9. Коллапс бронзового века', page: 217 },
      { title: 'Глава 10. Современные изменения климата', page: 253 }
    ];

    function buildTOC() {
      tocList.innerHTML = '';
      tocEntries.forEach(ent => {
        const b = document.createElement('button');
        b.textContent = ent.title;
        b.addEventListener('click', () => { pageNum = ent.page; savePos(); render(true); drawer.classList.remove('open'); closeMenu(); });
        tocList.appendChild(b);
      });
    }

    function savePos() {
      localStorage.setItem('mPage', String(pageNum));
      localStorage.setItem('mMode', mode);
      localStorage.setItem('mUserScale', String(Math.round(userScale*100)));
    }

    function setBodyState(key, on) { document.body.classList.toggle(key, on); }

    function toggleChrome(show) {
      if (typeof show === 'boolean') showChrome = show; else showChrome = !showChrome;
      setBodyState('chrome-visible', showChrome);
    }

    function openMenu() {
      modalPageMeta.textContent = `Стр. ${pageNum} / ${totalPages}`;
      modalBackdrop.classList.add('open');
      setBodyState('modal-open', true);
      // Sync slider with current zoom
      zoomSlider.value = String(Math.round(userScale*100));
    }
    function closeMenu() {
      modalBackdrop.classList.remove('open');
      setBodyState('modal-open', false);
    }

    function updateMeta() {
      pageMeta.textContent = `Стр. ${pageNum} / ${totalPages}`;
      modalPageMeta.textContent = `Стр. ${pageNum} / ${totalPages}`;
    }

    pdfjsLib.getDocument(PDF_URL).promise.then(pdf => {
      pdfDoc = pdf; totalPages = pdf.numPages;
      const storedPage = parseInt(localStorage.getItem('mPage') || '1', 10);
      if (!isNaN(storedPage) && storedPage >= 1 && storedPage <= totalPages) pageNum = storedPage;
      const storedUserScale = parseInt(localStorage.getItem('mUserScale') || '100', 10);
      if (!isNaN(storedUserScale)) userScale = Math.max(0.7, Math.min(3.0, storedUserScale/100));
      buildTOC();
      render(true);
    }).catch(err => console.error('PDF load error:', err));

    function computeBaseScale(page) {
      const targetW = Math.min(window.innerWidth, document.documentElement.clientWidth);
      const vp1 = page.getViewport({ scale: 1 });
      originalPageWidth = vp1.width;
      return targetW / originalPageWidth;
    }

    function applyPanClamp() {
      // Clamp pan so that blank margins don’t appear too far; allow a little overscroll elasticity
      const wrapRect = pageWrap.getBoundingClientRect();
      const stageRect = stage.getBoundingClientRect();
      const overX = Math.max(0, (wrapRect.width - stageRect.width)/2);
      const overY = Math.max(0, (wrapRect.height - stageRect.height)/2);
      panX = Math.max(-overX-60, Math.min(overX+60, panX));
      panY = Math.max(-overY-60, Math.min(overY+60, panY));
    }

    function applyTransform() {
      pageWrap.style.transform = `translate(calc(50% + ${panX}px), calc(50% + ${panY}px)) translate(-50%,-50%) scale(${userScale})`;
    }

    let rerenderScheduled = null;
    function scheduleHiDpiRerender() {
      // Debounce re-render at the new zoom level so images stay crisp
      if (rerenderScheduled) cancelAnimationFrame(rerenderScheduled);
      rerenderScheduled = requestAnimationFrame(() => render(false));
    }

    function render(initial=false) {
      if (!pdfDoc) return;
      pdfDoc.getPage(pageNum).then(page => {
        baseScale = computeBaseScale(page);
        const dpr = window.devicePixelRatio || 1;
        const s = baseScale * userScale;
        const viewport = page.getViewport({ scale: s });
        canvas.width = Math.floor(viewport.width * dpr);
        canvas.height = Math.floor(viewport.height * dpr);
        canvas.style.width = Math.floor(viewport.width) + 'px';
        canvas.style.height = Math.floor(viewport.height) + 'px';
        const rc = { canvasContext: ctx, viewport, transform: dpr !== 1 ? [dpr,0,0,dpr,0,0] : null };
        page.render(rc).promise.then(() => {
          updateMeta();
          if (initial) {
            // Reset pan on first render/page change
            panX = 0; panY = 0;
            applyTransform();
          } else {
            applyPanClamp();
            applyTransform();
          }
        });
      });
    }

    // Paging taps (always available)
    zonePrev.addEventListener('click', () => { if (pageNum > 1) { pageNum--; savePos(); render(true); } });
    zoneNext.addEventListener('click', () => { if (pageNum < totalPages) { pageNum++; savePos(); render(true); } });
    zoneToggle.addEventListener('click', () => { openMenu(); toggleChrome(true); });

    // Gestures: pinch to zoom, one-finger pan when zoomed; otherwise swipe page
    let touchMode = 'idle'; // 'idle' | 'pan' | 'pinch' | 'swipe'
    let lastX=0, lastY=0, lastDX=0, lastDY=0, startX=0, startY=0;
    let startDist=0, startScale=1;

    function dist(t0,t1){ const dx=t1.clientX-t0.clientX, dy=t1.clientY-t0.clientY; return Math.hypot(dx,dy); }

    stage.addEventListener('touchstart', (e) => {
      if (e.touches.length === 2) {
        touchMode = 'pinch';
        startDist = dist(e.touches[0], e.touches[1]);
        startScale = userScale;
      } else if (e.touches.length === 1) {
        startX = lastX = e.touches[0].clientX;
        startY = lastY = e.touches[0].clientY;
        if (userScale > 1.02) {
          touchMode = 'pan';
        } else {
          touchMode = 'swipe';
        }
      }
    }, {passive:false});

    stage.addEventListener('touchmove', (e) => {
      if (touchMode === 'pinch' && e.touches.length === 2) {
        e.preventDefault();
        const d = dist(e.touches[0], e.touches[1]);
        const factor = d / (startDist || d);
        userScale = Math.max(0.7, Math.min(3.0, startScale * factor));
        zoomSlider.value = String(Math.round(userScale*100));
        mode = 'manual';
        applyPanClamp();
        applyTransform();
        scheduleHiDpiRerender();
      } else if (touchMode === 'pan' && e.touches.length === 1) {
        e.preventDefault();
        const x = e.touches[0].clientX, y = e.touches[0].clientY;
        const dx = x - lastX, dy = y - lastY;
        lastX = x; lastY = y;
        panX += dx; panY += dy;
        applyPanClamp();
        applyTransform();
      } else if (touchMode === 'swipe' && e.touches.length === 1) {
        // Let swipe finish on touchend to decide direction
        lastX = e.touches[0].clientX;
        lastY = e.touches[0].clientY;
      }
    }, {passive:false});

    stage.addEventListener('touchend', (e) => {
      if (touchMode === 'swipe') {
        const dx = lastX - startX, dy = lastY - startY;
        if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 40) {
          if (dx < 0 && pageNum < totalPages) { pageNum++; savePos(); render(true); }
          if (dx > 0 && pageNum > 1) { pageNum--; savePos(); render(true); }
        }
      }
      if (touchMode === 'pinch') {
        scheduleHiDpiRerender();
      }
      touchMode = 'idle';
    }, {passive:false});

    // Topbar buttons
    menuBtn.addEventListener('click', () => { drawer.classList.toggle('open'); });
    aaBtn.addEventListener('click', () => toggleChrome());

    tocBtn.addEventListener('click', () => { drawer.classList.add('open'); });
    closeModal.addEventListener('click', () => { closeMenu(); toggleChrome(false); });

    // Go to page
    gotoBtn.addEventListener('click', () => {
      const p = parseInt(gotoInput.value || '0', 10);
      if (!isNaN(p) && p >= 1 && p <= totalPages) {
        pageNum = p; savePos(); render(true); closeMenu(); toggleChrome(false);
      }
    });

    // Search across pages
    let searchResults = [];
    let searchIndex = -1;
    let textCache = {}; // pageNum -> text

    async function getPageText(num) {
      if (textCache[num]) return textCache[num];
      const pg = await pdfDoc.getPage(num);
      const content = await pg.getTextContent();
      const strings = content.items.map(it => it.str);
      const text = strings.join(' ');
      textCache[num] = text;
      return text;
    }

    async function buildSearch(q) {
      searchResults = [];
      searchIndex = -1;
      if (!q) { searchCount.textContent = '0 совпадений'; return; }
      const needle = q.toLowerCase();
      for (let i = 1; i <= totalPages; i++) {
        const txt = (await getPageText(i)).toLowerCase();
        if (txt.includes(needle)) searchResults.push(i);
      }
      searchCount.textContent = searchResults.length + ' совпадений';
      if (searchResults.length) {
        // jump to first result near current page
        const nearest = searchResults.reduce((best, p) => {
          const d = Math.abs(p - pageNum);
          if (best === null || d < Math.abs(best - pageNum)) return p;
          return best;
        }, null);
        searchIndex = searchResults.indexOf(nearest);
        pageNum = nearest; savePos(); render(true);
      }
    }

    function gotoSearch(offset) {
      if (!searchResults.length) return;
      searchIndex = (searchIndex + offset + searchResults.length) % searchResults.length;
      pageNum = searchResults[searchIndex];
      savePos(); render(true);
    }

    searchBtn.addEventListener('click', () => buildSearch(searchInput.value.trim()));
    searchNext.addEventListener('click', () => gotoSearch(+1));
    searchPrev.addEventListener('click', () => gotoSearch(-1));

    // Zoom controls in bottom bar
    function setScaleFromSlider(v) {
      mode = 'manual';
      userScale = Math.max(0.7, Math.min(3.0, v / 100));
      savePos();
      scheduleHiDpiRerender();
      applyPanClamp();
      applyTransform();
    }
    zoomSlider.addEventListener('input', (e) => setScaleFromSlider(parseInt(e.target.value,10)));
    zoomInBtn.addEventListener('click', () => setScaleFromSlider(Math.min(300, parseInt(zoomSlider.value,10) + 10)));
    zoomOutBtn.addEventListener('click', () => setScaleFromSlider(Math.max(70, parseInt(zoomSlider.value,10) - 10)));
    fitBtn.addEventListener('click', () => {
      mode = 'fit'; userScale = 1; panX = 0; panY = 0; zoomSlider.value = '100';
      savePos(); render(true);
    });

    // Orientation / resize reflow -> width-fit base recalculated
    window.addEventListener('resize', () => render(false));

    // Close drawer with swipe
    let drawerStartX = null;
    drawer.addEventListener('touchstart', (e) => { if (e.touches.length===1) drawerStartX = e.touches[0].clientX; }, {passive:true});
    drawer.addEventListener('touchend', (e) => {
      if (drawerStartX==null) return;
      const dx = e.changedTouches[0].clientX - drawerStartX;
      if (dx > 70) drawer.classList.remove('open');
      drawerStartX = null;
    }, {passive:true});
  </script>
</body>
</html>
